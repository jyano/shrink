b2d.p()
b.hit= b.h=function (x, y, dot) {var b = this, w = b.W(), g=G(arguments)

    hit

    if (g.p) {w.dot(x, y)}

    b.fs(function (f) {

        if (f.hit(x, y)) { hit = true }

    })

    return hit
}
f.tP=  f.hit=f.testPoint=f.test=function(){var f=this,b=f.B(),w=b.W(),g=G(arguments),  v

    v = V(g.f, g.s)

    if(g.p){ w.dot(v) }

    return f.H().TestPoint(
        b.tf(),
        v.div()
    )

    //is a point within the fixture // very accurate

}
b.fSp=function(){
    return  this.f().sprites[0]
}
ct.d= ct.dot=function(c, x, y){var ct=this, o, d, tw, g=G(arguments)

    if(b2d.isGPoly(g.f)){

        _.e(g.f.vs(), function(v){ct.dot(V(v))})

        return this
    }


    if(g.A){

        _.e(c, function(G){
            if( A(G) ){ ct.dot.apply(ct, G) }
            else { ct.dot(G) }
        })

        return this
    }


    o = g.S_? (

        b2d.iB(g.s)? {c:g.f, x:g.s.sX , y: g.s.sY }:

            O(g.s)? {c:g.f, x:g.s.x, y: g.s.y}:
            {c:g.f, x:g.s, y: g.t}

    ):
        b2d.iB(g.f)? { x:g.f.sX , y: g.f.sY }:
            g.O_? {x:g.f.x,  y: g.f.y}:
            {x:g.f, y:g.s}



    o.x= N(o.x, ct.W()/2)
    o.y= N(o.y, ct.H()/2)
    o.c = o.c||'y'
    d = this.h(o.x, o.y).cir(8,  o.c, 'z', 2).al(.7).drag()
    tw=d.twL( [{sxy:1.3},100], [{sxy:1},100]).$()
    d.$$(function(){ tw.$() })
    return d.K('dev dot')
}
f.dot = function (c) {
    var f = this, w = f.B().W(), v

    v = f.cen()

    if (S(c)) {
        w.dot(c, v)
    }
    else {
        w.dot(v)
    }

    return f
}


w.mu = function (fn) {var w = this

    $(w.i.canvas).mU(function (e) {
        fn({x: w.mx, y: w.my, e: e})
    })

    return w
}


w.mm = function (fn) {
    var w = this, g = G(arguments)
    $.mm(function (e) {
        var o = {x: w.mx, y: w.my, X: e.clientX, Y: e.clientY, e: e}
        fn(o)
    })
    return w
}
w.$$ = function (fn) {
    var w = this
    w.UI().dblclick(function (e) {
        fn({x: w.mx, y: w.my, e: e})
    })
    return w
}
b.dot = function () {
    var b = this, w = b.W(), g = G(arguments)
    g.N_ ? (
        g.p ?
            T.t(function () {
                b.dot(g.f, g.s)
            }) :
            w.d(b.wP(g.f, g.s)))
        :

        w.d(g.f || 'y', g.p ? b.wC() : b)

    return b

}
b.$ = function (fn) {
    var b = this, w = b.W()
    w.$(function (o) {
        w.q(o.x, o.y, function (f) {
            if (f.of(b)) {
                _.b(fn, f)(o)
            }
        })
    })

    return b

}
b.$$ = function (fn) {
    var b = this, w = b.W()
    w.$$(function (o) {
        w.q(o.x, o.y, function (f) {

            if (f.of(b)) {
                _.b(fn, f)(o)
            }
        })
    })
    return b
}
f.$ = function (fn) {
    var f = this, b = f.B(), w = b.W()
    w.$(function (o) {
        w.q(o.x, o.y, function (fx) {
            if (f == fx) {
                _.b(fn, f)(o)
            }
        })
    })
    return f
}
spProto()
world()
body()
easel()
sprite()

b2d.oDef = function (o) {
    o = o || {}
    o.x = N(o.x, 0)
    o.y = N(o.y, 0)
    o.a = N(o.a, 0)
    o.w = N(o.w, 50)
    o.h = N(o.h, 50)
    o.c = o.c || 'z'
    o.C = o.C || 'w'
    return o
}
function easel() {

    b2d.cov = function(x,y,c,C,l,l2){
        var g=G(arguments),x=g[0],y=g[1],c=g[2],C=g[3],l=g[4],l2=g[5],

            o = N(c)? {x:x, y:y, a:c, c:C, C:l, l:l2}
                : N(x)? {x:x, y:y, c:c, C:C, l:l}
                : x,
            h = new cjs.Shape()

        b2d.oDef(o)

        h.XY(o.x,o.y).rot(o.a).c(o.c,o.C,o.l)

        if(o.d){h.drag()}

        return h
    }

    b2d.grad=function(o){
        o=o||{}

        o.c1 = oO('c',o.c1||'z')
        o.c2 = oO('c',o.c2||'w')

        o.s1 = N(o.s1)
        o.s2 = N(o.s2, 1)
        o.x1 = N(o.x1)
        o.y1 = N(o.y1)

        return o
    }

    T.tx = function () {
    }

    i.dr = function (dr) {
        if (U(dr)) {
            return this.direction
        }
        this.direction = dr;
        return this
    }
    i.nm = function (dr) {
        if (U(dr)) {
            return this.name
        }
        this.name = dr;
        return this
    }

// Hit testing the screen width, otherwise our sprite would disappear //
// We've reached the right side of our screen
// We need to walk left now to go back to our initial position
//sS.addFlipped(true, false, false)// walk_h has been generated by addFlippedFrames and// contained the right facing animations
//T.f(40)
    ct.reset = function () {
        this.St().removeAllChildren()
        T.removeAllListeners()
    }
//sprite.shadow = new createjs.Shadow("#454", 10, 15, 14)
//spriteUrl = "/assets/sprites/metalslug_mummy37x45.png"
//sprite always assumed to start facing right (and flipping it horizontqlly is the left) - so i must draw facing right
}
function spProto() {
    sp.p = function (an) {
        var sp = this

        if (U(an)) {
            sp.play()
        }
        else {
            sp.gotoAndPlay(an)
        }
        return sp
    }
    sp.s = s.P = function (an) {
        var sp = this
        if (U(an)) {
            sp.stop()
        }
        else {
            sp.gotoAndStop(an)
        }
        return sp
    }
    sp.N = function (n) {
        this.advance(n);
        return this
    }
    sp.as = function () {

        return this.spriteSheet.getAnimations()
    }
    sp.a = function () {
        return this.currentAnimation
    }
    sp.f = function (f) {
        var g = G(arguments)
        if (U(f)) {
            return g.p ? this.currentFrame : this.currentAnimationFrame
        }
        if (g.p) {
            this.currentFrame = f
        }
        else {
            this.currentAnimationFrame = f
        }
        return this
    }
    sp.r = _.gS(sp, 'framerate')
    sp.e = function (fn) {
        fn = fn || function () {
                n = N(window['n'], 0);
                $l('frame! ' + n++)
            }
        this.on('animationend', fn)
        return this
    }
}
function world() {

    w=b2d.World.prototype

//ticker
    w.tE=function(fn){var w=this
        T.t(function(){  w.e(fn)  })
        return this
    }


    w.d = w.dot = function () {
        var w = this, g = G(arguments), o

        if (g.S_) {
            o = N(g.s) ?
            {c: g.f, x: g.s, y: g[2]} :
            {c: g.f, x: V(g.s).x, y: V(g[1]).y}
        }

        else {
            o = N(g.s) ?
            {x: g.f, y: g.s} :

            {x: V(g.f).x, y: V(g.f).y}
        }


        if (g.m) {
            w.dot(o.c, o.x, o.y, '-')
            w.dot(o.c, o.x, o.y, '/')
            w.dot(o.c, o.x, o.y, '+')
            w.dot(o.c, o.x, o.y)
        }

        else if (g.p) {
            w.fg.dot(o.c, o.x, o.y)
        }
        else if (g.n) {
            w.bg.dot(o.c, o.x, o.y)
        }
        else if (g.d) {
            w.g.dot(o.c, o.x, o.y)
        }
        else {
            w.i.dot(o)
        }
        return w
    }
    w.md = function (fn) {
        var w = this
        w.i.c.mousedown(function (e) {
            var o = {x: w.mx, y: w.my, X: e.clientX, Y: e.clientY, e: e}
            w.q(w.mx, w.my, function (f) {
                if (f) {
                    o.f = f;
                    o.b = f.B()
                }
            })
            fn(o)
        })
        return w
    }

    w.$=function(fn){var w=this
        w.UI().click(function(e){fn({x:w.mx, y:w.my, e:e})})
        return w
    }
    w.e$=function( ){var g=G(arguments),o
        o=  F(g.s) ? {k: g.f, fn: g.s} : {fn: g.f}
        this.e(function(b){ if(b.of(o.k)){b.$(o.fn)} })
        return this
    }


    w.lG=function(c,c2){var w=this,o
        o={c1:c2||'z', c2:c||'r', x1:0,y1:0,x2:0,y2:0}
        _.x(o,R()?(R()?{y2:w.h}:{x2:w.w}):
            R()?(R()?{x1:w.w,y1:w.h}:{x2:w.w,y2:w.h}):
                R()?{x1:w.w,y2:w.h}:{y1:w.h,x1:w.w})
        w.bg.h().lf(o).dr(0,0,w.w,w.h)
        w.bg.h(0, 0, $r()).dr(0, 0, w.w, w.h).al(.2)

        return w
    }
    w.C = function (c) {
        var w = this
        w.bg.h().c(c || $r()).dr(0, 0, w.w, w.h)
        return w
    }

    w.$h = function () {
        return this.i.h.apply(this.i, arguments)
    } // h = $h().a2(s).rXY(100, 300).XY(100,300).drag()
//  h.rec( 'r','b',600, 200,  600, 200)
// h.rec( 'g',100, 100,  100, 20)


    w.l = w.dl = function(){
        var w = this, g = G(arguments), o, i
        o = S(g[0]) ? {c: g[0], x1: g[1], y1: g[2], x2: g[3], y2: g[4]}
            :
        {x1: g[0], y1: g[1], x2: g[2], y2: g[3]}
        i = g.p ? w.fg : g.n ? w.bg : g.d ? w.g : w.i
        o.c = o.c || (g.p ? 'p' : g.n ? 'r' : g.d ? 'd' : 'b')

        return i.h()
            .c(10, o.c)
            .mt(o.x1, o.y1)
            .lt(o.x2, o.y2).K('dev line')


    }

    w.dr = function (c, x, y, W, h) {
        var w = this, g = G(arguments), o
        o = g.S_ ? {c: g[0], x: g[1], y: g[2], w: g[3], h: g[4]}
            : {x: g[0], y: g[1], w: g[2], h: g[3]}
        _.x(o, g.p ? {g: w.fg, c: o.c || 'p'} :
            g.n ? {g: w.bg, c: o.c || 'r'} :
            {g: w.hud, c: o.c || 'b'})
        o.g.h().rec(o)
    }

    w.dbCross = function (x, y) {
        var w = this, c = w.cen()
        x = N(x, c.x)
        y = N(y, c.y)

        w.dr('t', -10 + x, -140 + y, 20, 300, '-')
        w.dr('t', -150 + x, -10 + y, 300, 20, '-')
        w.dot('r', x, y)

        return w

    }
    w.stats = function (n) {
        var w = this
        _d = $.d(400, 600, w.W, 0, '+').A($.h1('stats'))

        w.mdq(function (fx) {
            _f = _d._fix = fx;
            _b = _f.B()
        })

        if (n == 0) {
            z(upd)
        }

        else {
            _.ev(N(n, .2), upd)
        }

        return w

        function upd() {
            var f, b;
            if (_d._fix) {
                f = _d._fix
                b = f.B()

                _d.T(
                    'ty: ' + (b.iD() ? 'dyn' : 'stat'),
                    'x: ' + b.X(),
                    'y: ' + b.Y(),
                    'fK: ' + f.K(), 'bK: ' + b.K(),
                    'sen: ' + f.sen(),
                    'd: ' + f.d(),
                    'fr: ' + f.fr(),
                    'r: ' + f.r(),
                    'bMass:' + parseInt(f.B().mass()),
                    'bNum:' + f.B().n()
                )

            }

        }
    }
    w.devGrid = function () {
        var w = this
        _.t(12, function (i) {
            w.l(i * 200, 0, i * 200, w.h)
            w.l(i * 200, 0, i * 200, w.h, '-')
            w.l(0, i * 200, w.w, i * 200)
            w.l(0, i * 200, w.w, i * 200, '-')
        })
        return w
    }
    w.flash = function () {
        var w = this, s = w.s
        s.flash.apply(s, arguments)
        return w
    }
    w._ = function (fn) {
        Q(function () {
            fn(w)
        })
    }


//stage to world
    w.sTW = w.sToW = function (x, y) {
        var w = this, //works
            x = x / w.z - w.s.x / w.z,
            y = y / w.z - w.s.y / w.z
        //w.dot(x,y,'*') // cool
        return {x: x, y: y}
    }

//world to stage
    w.wTS = w.wToS = function (x, y) {
        var w = this,
            x = (x + w.s.x / w.z) * w.z,
            y = (y + w.s.y / w.z) * w.z
        return {x: x, y: y}
    }


    w.cen = w.cent = function () {
        var w = this, g = G(arguments),
            v = V(w.s.W() / 2, w.s.H() / 2)
        if (g.p) {w.dot(v)}
        return v
    }
    w.pop = function (t) {
        var w = this
        t = this.i.T(t || 'no text', 80, 'o', w.hW, 200)
        t.tw([{a: .5, sxy: .5}, 4000])
        $.in(4, function () {
            t.rm()
        })
        return this
    }

    w.pen = function (t, f, c) {
        var g = G(arguments), o
        if (this._T) {
            this._T.rm();
            this._T = null
        }

        o = {y: 100}

        o.x = g.n ? 200 : g.p ? this.W - 200 : this.hW

        this._T = this.i.T(t, f, c)
        this._T.XY(o.x, o.y)
        return this._T
    }
    w.chalk = function () {
        var w = this, g = G(arguments)
        w.i.chalk.apply(w.i, g)
        return w
    }
    w.show = function (fn) {
        var w = this, g = G(arguments)


        _.ev(.2, function () {

            w.pen(S(fn) ? window[fn] : fn())

        })

        return w

    }
    w.th = w.thrust = function (c, x, y, r) {
        return this.D(N(x, 600), N(y, 500), c || 'b', N(r, 40)).cn('thrust')
    }
    w.PackThruster = w.pack = function (ani) {

        var th = w.th(600, 500, 'b', 100).C("X")
            .r(1).fR()

        th.Sp(Pack, 0, 0, .8)

        return th.p(ani || 'f1')
    }


    //test color
    w.txC = function () {
        var w = this
        _.ev(2, function () {
            w.e(function (b) {
                b.fs(function (f) {
                    f.C($r())
                })
            })
        })
    }

    w.sH = function (h) {
        var w = this
        if (U(h)) {return w.H * w.s.scaleY}
        w.s.scaleY = h / w.H
        return w
    }

    tweenStuff()
    function tweenStuff() {
        w.ps = tw.pos
        w.iGP = tw.ignore
    }


}
function body() {
    b.dr=function(dr){
        if(U(dr)){return this.direction}
        this.direction=dr; return this
    }

    b.p = b.play = function (a, b, c, d) {
        if (O(this.sp())) {
            this.sp().p(a, b, c, d)
        }
        return this
    }
    b.s = b.stop = function (a, b, c, d) {
        if (O(this.sp())) {
            this.sp().s(a, b, c, d)
        }
        return this
    }
}
function sprite(){
    meSprite=function(){
        return $Sp( $SS ).XY(10).drag()
    }



    cjs.sSU = cjs.SpriteSheetUtils
    sS.flp=sS.addFlipped=function(a, b, c){
        cjs.sSU.addFlippedFrames(this,  a||true, b||false, c||false )
        return this
    }

    SSBuilder()
    function SSBuilder() {


        sSB.Z = function (sc) {
            if (U(sc)) {
                return this.scale
            }
            this.scale = sc;
            return this
        }
        sSB.maxW = function (sc) {
            if (U(sc)) {
                return this.maxWidth
            }
            this.maxWidth = sc;
            return this
        }
        sSB.A = function (mc) {
            this.addMovieClip(mc)
            return this
        }
        sSB.complete = function (func) {
            this.on("complete", func)
            return this
        }
        sSB.async = function (funcNum, num) {
            if (F(funcNum)) {
                this.complete(funcNum)
                this.buildAsync(num)
            }

            else {
                this.buildAsync(funcNum)
            }


            return this
        }


        cjs.sSB = cjs.builder = cjs.spriteSheetBuilder = cjs.ssB = cjs.ssb = function (mc) {

            var sSB = new cjs.SpriteSheetBuilder()
            if (mc) {
                sSB.A(mc)
            }
            return sSB
        }
    }


}
$.fn.wor = $.fn.world = function () {
    var can = this
    var w = b2d.wor.apply(null, arguments).bug(can, 30, '*')
    w.can = can
    w.ctx = can.ctx()
    return w
}
//create container
ct.aC=function(ac){
    var ct=this
    if(U(ac)){return ct.autoClear}
    ct.autoClear = ac?true:false;
    return ct
}
//create ticker
T.iP=function(){
    return T.getPaused()
}
//spaz
w.UI=function(){return $(this.i.canvas)}
b2d.p()
f.$ = function (fn) {
    var f = this, b = f.B(), w = b.W()
    w.$(function (o) {
        w.q(o.x, o.y, function (fx) {
            if (f == fx) {
                _.b(fn, f)(o)
            }
        })
    })
    return f
}
f.tP=  f.hit=f.testPoint=f.test=function(){var f=this,b=f.B(),w=b.W(),g=G(arguments),  v

    v = V(g.f, g.s)

    if(g.p){ w.dot(v) }

    return f.H().TestPoint(
        b.tf(),
        v.div()
    )

    //is a point within the fixture // very accurate

}
f.dot = function (c) {
    var f = this, w = f.B().W(), v

    v = f.cen()

    if (S(c)) {
        w.dot(c, v)
    }
    else {
        w.dot(v)
    }

    return f
}

b.$ = function (fn) {
    var b = this, w = b.W()
    w.$(function (o) {
        w.q(o.x, o.y, function (f) {
            if (f.of(b)) {
                _.b(fn, f)(o)
            }
        })
    })

    return b

}
b.hit= b.h=function (x, y, dot) {var b = this, w = b.W(), g=G(arguments),hit
    if (g.p) {w.dot(x, y)}
    b.fs(function (f) {if (f.hit(x, y)) { hit = true }})
    return hit}
b.fSp=function(){
    return  this.f().sprites[0]
}
b.dot = function () {
    var b = this, w = b.W(), g = G(arguments)
    g.N_ ? (
        g.p ?
            T.t(function () {
                b.dot(g.f, g.s)
            }) :
            w.d(b.wP(g.f, g.s)))
        :

        w.d(g.f || 'y', g.p ? b.wC() : b)

    return b

}

b.$$ = function (fn) {
    var b = this, w = b.W()
    w.$$(function (o) {
        w.q(o.x, o.y, function (f) {

            if (f.of(b)) {
                _.b(fn, f)(o)
            }
        })
    })
    return b
}
b.dr=function(dr){
    if(U(dr)){return this.direction}
    this.direction=dr; return this
}
b.p = b.play = function (a, b, c, d) {
    if (O(this.sp())) {
        this.sp().p(a, b, c, d)
    }
    return this
}
b.s = b.stop = function (a, b, c, d) {
    if (O(this.sp())) {
        this.sp().s(a, b, c, d)
    }
    return this
}

i.dr = function (dr) {
    if (U(dr)) {
        return this.direction
    }
    this.direction = dr;
    return this
}
i.nm = function (dr) {
    if (U(dr)) {
        return this.name
    }
    this.name = dr;
    return this
}

ct.d= ct.dot=function(c, x, y){var ct=this, o, d, tw, g=G(arguments)

    if(b2d.isGPoly(g.f)){

        _.e(g.f.vs(), function(v){ct.dot(V(v))})

        return this
    }


    if(g.A){

        _.e(c, function(G){
            if( A(G) ){ ct.dot.apply(ct, G) }
            else { ct.dot(G) }
        })

        return this
    }


    o = g.S_? (

        b2d.iB(g.s)? {c:g.f, x:g.s.sX , y: g.s.sY }:

            O(g.s)? {c:g.f, x:g.s.x, y: g.s.y}:
            {c:g.f, x:g.s, y: g.t}

    ):
        b2d.iB(g.f)? { x:g.f.sX , y: g.f.sY }:
            g.O_? {x:g.f.x,  y: g.f.y}:
            {x:g.f, y:g.s}



    o.x= N(o.x, ct.W()/2)
    o.y= N(o.y, ct.H()/2)
    o.c = o.c||'y'
    d = this.h(o.x, o.y).cir(8,  o.c, 'z', 2).al(.7).drag()
    tw=d.twL( [{sxy:1.3},100], [{sxy:1},100]).$()
    d.$$(function(){ tw.$() })
    return d.K('dev dot')
} // Hit testing the screen width, otherwise our sprite would disappear //
// We've reached the right side of our screen
// We need to walk left now to go back to our initial position
//sS.addFlipped(true, false, false)// walk_h has been generated by addFlippedFrames and// contained the right facing animations
//T.f(40)
ct.reset = function () {
    this.St().removeAllChildren()
    T.removeAllListeners()
} //sprite.shadow = new createjs.Shadow("#454", 10, 15, 14)
//spriteUrl = "/assets/sprites/metalslug_mummy37x45.png"
//sprite always assumed to start facing right (and flipping it horizontqlly is the left) - so i must draw facing right

b2d.cov = function(x,y,c,C,l,l2){
    var g=G(arguments),x=g[0],y=g[1],c=g[2],C=g[3],l=g[4],l2=g[5],

        o = N(c)? {x:x, y:y, a:c, c:C, C:l, l:l2}
            : N(x)? {x:x, y:y, c:c, C:C, l:l}
            : x,
        h = new cjs.Shape()

    b2d.oDef(o)

    h.XY(o.x,o.y).rot(o.a).c(o.c,o.C,o.l)

    if(o.d){h.drag()}

    return h
}
b2d.grad=function(o){
    o=o||{}

    o.c1 = oO('c',o.c1||'z')
    o.c2 = oO('c',o.c2||'w')

    o.s1 = N(o.s1)
    o.s2 = N(o.s2, 1)
    o.x1 = N(o.x1)
    o.y1 = N(o.y1)

    return o
}
b2d.oDef = function (o) {
    o = o || {}
    o.x = N(o.x, 0)
    o.y = N(o.y, 0)
    o.a = N(o.a, 0)
    o.w = N(o.w, 50)
    o.h = N(o.h, 50)
    o.c = o.c || 'z'
    o.C = o.C || 'w'
    return o
}

$.fn.wor = $.fn.world = function () {
    var can = this
    var w = b2d.wor.apply(null, arguments).bug(can, 30, '*')
    w.can = can
    w.ctx = can.ctx()
    return w
}
//create container
ct.aC=function(ac){
    var ct=this
    if(U(ac)){return ct.autoClear}
    ct.autoClear = ac?true:false;
    return ct
}


//create ticker
T.iP=function(){return T.getPaused()}
T.tx = function () {}


//spaz
w.UI=function(){return $(this.i.canvas)}